# -*- coding: utf-8 -*-

import re
from typing import Optional, List, Tuple

import cv2
import numpy as np
import easyocr
from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse


app = FastAPI(title="Plate OCR API", version="1.0.0")

# EasyOCR (CPU)
reader = easyocr.Reader(["pt", "en"], gpu=False)

ALLOWLIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

RE_OLD = re.compile(r"^[A-Z]{3}\d{4}$")         # AAA1234
RE_MERC = re.compile(r"^[A-Z]{3}\d[A-Z]\d{2}$") # AAA1A23


TO_DIGIT = str.maketrans({
    "O": "0", "Q": "0", "D": "0",
    "I": "1", "L": "1",
    "S": "5",
    "B": "8",
    "Z": "2",
})

TO_LETTER = str.maketrans({
    "0": "O",
    "1": "I",
    "2": "Z",
    "5": "S",
    "8": "B",
})


def normalize_text(s: str) -> str:
    s = (s or "").upper()
    s = re.sub(r"[^A-Z0-9]", "", s)
    return s


def is_plate(s: str) -> bool:
    return bool(RE_OLD.match(s) or RE_MERC.match(s))


def preprocess_gray(bgr: np.ndarray) -> np.ndarray:
    gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.bilateralFilter(gray, 9, 75, 75)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    gray = clahe.apply(gray)
    return gray


def preprocess_bin_from_gray(gray: np.ndarray) -> np.ndarray:
    # Adaptive threshold costuma funcionar melhor em placa pequena
    th = cv2.adaptiveThreshold(
        gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY,
        31, 5
    )
    return th


def sharpen(bgr: np.ndarray) -> np.ndarray:
    k = np.array([[0, -1, 0],
                  [-1, 5, -1],
                  [0, -1, 0]], dtype=np.float32)
    return cv2.filter2D(bgr, -1, k)


def rotate_small(img: np.ndarray, deg: float) -> np.ndarray:
    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((w / 2, h / 2), deg, 1.0)
    return cv2.warpAffine(img, M, (w, h), flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)


def order_points(pts: np.ndarray) -> np.ndarray:
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]  # tl
    rect[2] = pts[np.argmax(s)]  # br
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]  # tr
    rect[3] = pts[np.argmax(diff)]  # bl
    return rect


def warp_quad(img: np.ndarray, quad: np.ndarray) -> np.ndarray:
    rect = order_points(quad.astype("float32"))
    (tl, tr, br, bl) = rect

    widthA = np.linalg.norm(br - bl)
    widthB = np.linalg.norm(tr - tl)
    maxW = int(max(widthA, widthB))

    heightA = np.linalg.norm(tr - br)
    heightB = np.linalg.norm(tl - bl)
    maxH = int(max(heightA, heightB))

    maxW = max(maxW, 220)
    maxH = max(maxH, 70)

    dst = np.array([
        [0, 0],
        [maxW - 1, 0],
        [maxW - 1, maxH - 1],
        [0, maxH - 1],
    ], dtype="float32")

    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(img, M, (maxW, maxH))
    return warped


def ocr_texts(img: np.ndarray) -> List[Tuple[str, float]]:
    res = reader.readtext(img, detail=1, paragraph=False, allowlist=ALLOWLIST)
    out: List[Tuple[str, float]] = []
    for _, text, conf in res:
        out.append((normalize_text(str(text)), float(conf)))
    return out


def fix_by_pattern(s: str) -> List[str]:
    """
    Gera candidatos aplicando regras por posição:
    - antiga: LLLDDDD
    - mercosul: LLLDLDD
    """
    s = normalize_text(s)
    if len(s) != 7:
        return [s]

    cands = set()

    # antigo
    t = list(s)
    for i in (0, 1, 2):
        t[i] = t[i].translate(TO_LETTER)
    for i in (3, 4, 5, 6):
        t[i] = t[i].translate(TO_DIGIT)
    cands.add("".join(t))

    # mercosul
    t = list(s)
    for i in (0, 1, 2, 4):
        t[i] = t[i].translate(TO_LETTER)
    for i in (3, 5, 6):
        t[i] = t[i].translate(TO_DIGIT)
    cands.add("".join(t))

    # também inclui o original
    cands.add(s)

    return [x for x in cands if len(x) == 7]


def choose_best_plate(img: np.ndarray) -> Optional[str]:
    texts = ocr_texts(img)

    best = None
    best_score = -1.0

    for raw, conf in texts:
        if len(raw) < 6:
            continue

        for cand in fix_by_pattern(raw):
            score = conf

            if is_plate(cand):
                score += 0.60  # bônus forte
            elif re.match(r"^[A-Z0-9]{7}$", cand):
                score += 0.05

            # prefere se confiança for alta
            if score > best_score:
                best_score = score
                best = cand

    if best and is_plate(best):
        return best

    # fallback relaxado (7 chars e confiança razoável)
    if best and re.match(r"^[A-Z0-9]{7}$", best) and best_score >= 0.75:
        return best

    return None


def build_variants(bgr: np.ndarray) -> List[np.ndarray]:
    """
    Variantes para OCR: ajuda MUITO em placa pequena/borrada
    """
    variants: List[np.ndarray] = []

    # Upscale forte primeiro
    bgr2 = cv2.resize(bgr, None, fx=3.0, fy=3.0, interpolation=cv2.INTER_CUBIC)
    variants.append(bgr2)

    g = preprocess_gray(bgr2)
    variants.append(g)

    th = preprocess_bin_from_gray(g)
    variants.append(th)

    inv = cv2.bitwise_not(th)
    variants.append(inv)

    sh = sharpen(bgr2)
    variants.append(sh)

    return variants


def find_plate_candidates(img_bgr: np.ndarray) -> List[np.ndarray]:
    """
    Retorna lista de ROIs candidatas.
    Estratégia: encontrar retângulos "placa-like" via morfologia + contornos.
    """
    h, w = img_bgr.shape[:2]
    gray = preprocess_gray(img_bgr)

    # Realça bordas horizontais/verticais
    grad = cv2.morphologyEx(gray, cv2.MORPH_GRADIENT, np.ones((3, 3), np.uint8))

    # Binariza
    _, bw = cv2.threshold(grad, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # Fecha para unir letras/placa
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 5))
    closed = cv2.morphologyEx(bw, cv2.MORPH_CLOSE, kernel, iterations=2)

    # Remove ruído
    closed = cv2.erode(closed, None, iterations=1)
    closed = cv2.dilate(closed, None, iterations=2)

    cnts, _ = cv2.findContours(closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return []

    # maiores primeiro
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:80]

    rois: List[np.ndarray] = []
    for c in cnts:
        area = cv2.contourArea(c)
        if area < (h * w) * 0.002:
            continue

        peri = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, 0.02 * peri, True)

        # tenta warp quando tiver 4 pontos
        if len(approx) == 4:
            x, y, ww, hh = cv2.boundingRect(approx)
            aspect = ww / float(hh + 1e-6)
            if 2.0 <= aspect <= 9.0 and ww >= 100 and hh >= 25:
                warped = warp_quad(img_bgr, approx.reshape(4, 2))
                rois.append(warped)
                if len(rois) >= 8:
                    break

        # fallback: usa bounding rect mesmo sem quad perfeito
        x, y, ww, hh = cv2.boundingRect(c)
        aspect = ww / float(hh + 1e-6)
        if 2.2 <= aspect <= 10.0 and ww >= 120 and hh >= 28:
            pad = int(max(4, hh * 0.10))
            x0 = max(0, x - pad)
            y0 = max(0, y - pad)
            x1 = min(w, x + ww + pad)
            y1 = min(h, y + hh + pad)
            crop = img_bgr[y0:y1, x0:x1]
            rois.append(crop)
            if len(rois) >= 10:
                break

    return rois


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/read-plate")
async def read_plate(file: UploadFile = File(...)):
    if not file.content_type or not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="File must be an image")

    data = await file.read()
    if not data:
        raise HTTPException(status_code=400, detail="Empty file")

    buf = np.frombuffer(data, dtype=np.uint8)
    img = cv2.imdecode(buf, cv2.IMREAD_COLOR)
    if img is None:
        raise HTTPException(status_code=400, detail="Invalid image")

    # 1) tenta várias ROIs candidatas
    candidates = find_plate_candidates(img)

    for roi in candidates:
        for v in build_variants(roi):
            for deg in (-6, -3, 0, 3, 6):
                plate = choose_best_plate(rotate_small(v, deg))
                if plate:
                    return JSONResponse(content=plate)

    # 2) fallback: OCR na imagem inteira (menos confiável)
    for deg in (-3, 0, 3):
        plate = choose_best_plate(rotate_small(img, deg))
        if plate:
            return JSONResponse(content=plate)

    # 3) fallback final: binarizada da imagem inteira
    gray = preprocess_gray(img)
    th = preprocess_bin_from_gray(gray)
    plate = choose_best_plate(th)

    return JSONResponse(content=plate)
