import re
from typing import List, Optional, Dict, Any

import cv2
import numpy as np
import easyocr
from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse


app = FastAPI(title="Plate OCR API", version="1.0.0")

# Leitor: PT/EN (placas BR podem ter letras e números)
# gpu=False para rodar em CPU sem complicação
reader = easyocr.Reader(["pt", "en"], gpu=False)


# Regex simples para formatos comuns no BR:
# - Antigo: ABC1234
# - Mercosul: ABC1D23 (onde D é letra)
PLATE_PATTERNS = [
    re.compile(r"^[A-Z]{3}\d{4}$"),
    re.compile(r"^[A-Z]{3}\d[A-Z]\d{2}$"),
]


def normalize_text(s: str) -> str:
    # Remove espaços/traços, deixa maiúsculo e filtra chars “estranhos”
    s = s.upper()
    s = re.sub(r"[^A-Z0-9]", "", s)
    return s


def looks_like_plate(s: str) -> bool:
    s = normalize_text(s)
    return any(p.match(s) for p in PLATE_PATTERNS)


def preprocess_for_ocr(img_bgr: np.ndarray) -> np.ndarray:
    """
    Pré-processamento leve:
    - grayscale
    - filtro bilateral (reduz ruído preservando bordas)
    - equalização (CLAHE)
    - binarização adaptativa
    """
    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.bilateralFilter(gray, d=9, sigmaColor=75, sigmaSpace=75)

    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    gray = clahe.apply(gray)

    thr = cv2.adaptiveThreshold(
        gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY,
        31, 5
    )
    return thr


def ocr_candidates(img: np.ndarray) -> List[Dict[str, Any]]:
    """
    Retorna candidatos do EasyOCR com:
    - text
    - confidence
    - bbox
    """
    # EasyOCR aceita np.ndarray (grayscale ou color)
    results = reader.readtext(img, detail=1, paragraph=False)
    cands = []
    for bbox, text, conf in results:
        cands.append({
            "text_raw": text,
            "text": normalize_text(text),
            "confidence": float(conf),
            "bbox": bbox,  # 4 pontos
            "is_plate_like": looks_like_plate(text),
        })
    # ordena por: primeiro os que parecem placa, depois confiança
    cands.sort(key=lambda x: (x["is_plate_like"], x["confidence"]), reverse=True)
    return cands


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/read-plate")
async def read_plate(file: UploadFile = File(...)):
    if not file.content_type or not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Envie um arquivo de imagem (image/*).")

    data = await file.read()
    if not data:
        raise HTTPException(status_code=400, detail="Arquivo vazio.")

    npbuf = np.frombuffer(data, dtype=np.uint8)
    img_bgr = cv2.imdecode(npbuf, cv2.IMREAD_COLOR)
    if img_bgr is None:
        raise HTTPException(status_code=400, detail="Não foi possível ler a imagem.")

    # OCR no original + OCR no pré-processado
    pre = preprocess_for_ocr(img_bgr)

    cands_original = ocr_candidates(img_bgr)
    cands_pre = ocr_candidates(pre)

    combined = (cands_original + cands_pre)
    # remove duplicados pelo texto, mantendo maior confiança
    best_by_text: Dict[str, Dict[str, Any]] = {}
    for c in combined:
        t = c["text"]
        if not t:
            continue
        if t not in best_by_text or c["confidence"] > best_by_text[t]["confidence"]:
            best_by_text[t] = c

    final = list(best_by_text.values())
    final.sort(key=lambda x: (x["is_plate_like"], x["confidence"]), reverse=True)

    best: Optional[Dict[str, Any]] = final[0] if final else None

    # Heurística: só “aceita” como placa se bater regex, ou se confiança muito alta
    plate = None
    if best:
        if best["is_plate_like"] or best["confidence"] >= 0.80:
            plate = best["text"]

    return JSONResponse({
        "plate": plate,
        "best_candidate": best,
        "candidates": final[:10],  # limita pra não explodir
    })
